#!/usr/bin/env python

#
# $Id: dls-get-se,v 1.12 2007/03/16 12:39:51 delgadop Exp $
#
# DLS Client. $Name:  $.
# Antonio Delgado Peris. CIEMAT. CMS.
# 

#########################################
# Imports 
#########################################
import dlsApi
DLS_VERB_HIGH = dlsApi.DLS_VERB_HIGH
DLS_VERB_WARN = dlsApi.DLS_VERB_WARN
from dlsDataObjects import DlsLocation, DlsFileBlock, DlsEntry
from os import environ
import dlsClient
from dlsCommandsCommon import *
import time
import sys
import getopt


################## GLOBAL CONSTANTS ########################
THIS_YEAR = time.localtime()[0]


######################### FUNCTIONS ########################

def usage():
   """
    Provides usage information
   """
   print "Usage: dls-get-se [-v, -e, -i, -l, --dbs-conf] <fileblock>"
   print "       dls-get-se [-v, -e, -i, -l, -p, --dbs-conf] -f <listing_file>"
   print "       dls-get-se -u"
   print "       dls-get-se -h"


def options():
   """
    Provides some information regarding the available options
   """
   print """Options summary:
   -h, --help
   -u, --usage
   -v, --verbose <verb_level>
   -e, --endpoint <endpoint>
   -i, --interface-type <iface_type>
   -l, --long
   -p, --partial-list
   -f, --from-file <filename>
       --dbs-conf <conf_file>
   """
def example():
  """
   Provides with an example of correct use of the script
  """
  print """
  """

def help():
   """
    Provides some help information
   """
   print """Prints the locations holding a copy of the specified FileBlock. 


Specific notes for DBS back-end (DLS_TYPE_DBS):

  The argument of this command will be taken as a FileBlock name pattern.
  All the locations associated with the matching FileBlocks will be returned.

  Currently, the DBS back-end does not support replica attributes, so the
  "-l" option is ignored.

  The server endpoint is got from a string in the URL form, usually:
    "http[s]://hname[:port]/path/to/DLS".
  This endpoint is retrieved from several sources (in order of precedence):   
     - specified value for --endpoint option 
     - DLS_ENDPOINT environmental variable
     - specified URL in the configuration file (see --dbs-conf)

  Apart from DBS endpoint, other configuration options may be specified for
  the underlying DBS interface (e.g. "level" for DBS logging level) in a
  configuration file. The name of this file can be indicated with,
  in this order:
     - specified value for --dbs-conf option
     - DBS_CLIENT_CONFIG environmental variable


Specific notes for LFC back-end (DLS_TYPE_LFC):
  
  The argument of this command is the a FileBlock name.

  For long listing ("-l"), printed attributes are: accees time, pin time,
  file type ('P' for permanent or 'V' for volatile) and SURL.

  The server endpoint should be of the form: "hname[:port][/path/to/DLS]",
  where a default port is used if not specified, and the path to DLS is
  required. The server endpoint is retrieved from (in orden of precedence):
     - specified value for --endpoint option 
     - DLS_ENDPOINT environmental variable


Specific notes for DLI back-end (DLS_TYPE_DLI):
 
  Long listing is not supported.

  All the other notes for LFC back-end apply to DLI as well.
  

Options: 

The "-l" option will cause some location attributes are printed after the SE name.
Printed attributes depend on the DLS implementation.

The "-f" option can be used to retrieve FileBlock names from a file rather
than from the given arguments. The file must contain one line per FileBlock
to be listed.

The "-p" option can be used together with "-f" to specify that even if there
are errors in the listing of locations for a fileblock specified in the file, 
the command must keep trying with the rest of fileblocks (by default, it will
break on error at the first problem). In the case of errors, a warning is
printed and the corresponding fileblock is skipped in the resulting locations
list. The "-p" option makes no sense if "-f" is not used.

The "-e" option can be used to set the DLS endpoint to use.

The "-i" option specifies the type of interface that should be used (which
depends on the DLS backend to access). If not specified, the interface type
is retrieved from:
    - DLS_TYPE environmental variable
If the interface type cannot be retrieved in any of these ways, the command fails.
Currently accepted values are:
    - DLS_TYPE_DBS =>   DLS_TYPE_DBS class (complete API with DBS back-end)
    - DLS_TYPE_LFC  =>  DlsLfcApi class (complete API with LFC back-end)
    - DLS_TYPE_DLI  =>  DlsDliClient class (getLocations only API with LFC back-end)
    - DLS_TYPE_MYSQL =>  DlsMySQLApi  class (complete API with MySQL proto back-end) 

The "-v" option sets the verbosity level for the command. Accepted values are:
  -v 0 ==> print nothing else than error messages
  -v 1 ==> print also warning messages (default)
  -v 2 ==> print extra debug information

If "-u" is specified, usage information is displayed.

If "-h" is specified, help information is displayed.
   """
   options()
   usage()



def showLocations(iface, lineList, longList, errorTolerant, verbose):
   """
    Prints the locations which hold a copy of the specified
    FileBlock. lineList is a list of strings, each holding 
    a FileBlock name. 
    
    If longList is True, some attributes are also printed.
    Currently printed attributes are: atime, ptime, f_type.
    
    Throws DlsApiError if there is a problem in the DLS operation.
   """

   fbList = []
   for line in lineList:

      # Split
      line = (line.strip()).split()
      if(not line):
         continue

      # Get LFN
      lfn = line.pop(0)

      # Store all the FileBlocks 
      fbList.append(lfn)

   if(verbose >= 2):
      print "--DlsApi.getLocations(",
      for i in fbList: print i, ";",
      print ")"

   # Get the locations (and let the caller deal with the exception...)
   entryList = iface.getLocations(fbList, longList = longList, session = True, errorTolerant = errorTolerant)

   # Print the entries
   for entry in entryList:
      if (len(entryList) > 1):
         print "  FileBlock: " + entry.fileBlock.name
      for loc in entry.locations:
         print loc.host,
         if(longList):
            values = []
            for i in ["atime", "ptime", "f_type", "sfn"]:
               try:
                   values.append(loc.attribs[i])
               except KeyError, inst:
                   values.append("UNKNOWN")

            if(not (values[0] == "UNKNOWN")):
               time_tuple = time.localtime(loc.attribs["atime"])
               if(time_tuple[0] != THIS_YEAR):
                  fmt = "%b %d %Y"
               else:
                  fmt = "%b %d %H:%M"
               print '\t', time.strftime(fmt, time_tuple), '\t',
            else:
               print '\t', values[1], '\t',

            print values[1], "\t",
            print values[2], "\t",
            print values[3],
         print
 

            

###################### MAIN FUNCTION ########################

def main(pArgs):
   """
    Performes the main task of the script (invoked directly).
    For information on its functionality, please call the help function.
   """

 # Options and args... 
 
   longoptions=["help", "usage", "long", "endpoint", "interface-type", "verbose", "from-file", "partial-list", "dbs-conf="]
   try:
      optlist, args = getopt.getopt(pArgs, 'hule:i:v:f:p', longoptions)
   except getopt.GetoptError, inst:
      sys.stderr.write("Bad usage: "+str(inst)+'\n')
      usage()
      sys.exit(OPT_ERROR)

   err=0
   longList = False
   dbsConf = None
   admitted_verb_values = [0, 1, 2]
   verbose = 1
   endpoint = None
   iface_type = None
   admitted_iface_types = ["DLS_TYPE_LFC", "DLS_TYPE_DLI", "DLS_TYPE_MYSQL", "DLS_TYPE_DBS"]
   fromFile = False
   fname=""
   errorTolerant = False
   for opt, val in optlist:
       if opt in ("-h", "--help"):
           help()
           return OPT_ERROR

       elif opt in ("-u", "--usage"):
           usage()
           return OPT_ERROR
           
       elif opt in ("-l", "--long"):
           longList = True
           
       elif opt in ("", "--dbs-conf"):
           dbsConf = val

       elif opt in ("-e","--endpoint"):
           endpoint = val

       elif opt in ("-p","--partial-list"):
           errorTolerant = True

       elif opt in ("-i", "--interface-type"):
           iface_type = val

       elif opt in ("-v", "--verbose"):
           try: 
             val = int(val)
           except ValueError, inst:
             sys.stderr.write("Unsupported verbosity value: " + val + "\n")
             return OPT_ERROR
           if (not (val in admitted_verb_values)):
              sys.stderr.write("Unsupported verbosity value: " + val + "\n")
              return OPT_ERROR             
           verbose = val

       elif opt in ("-f","--from-file"):
           fromFile = True
           fname = val


   # Check the interface type (from options or environ)
   if (not iface_type):
      iface_type = environ.get("DLS_TYPE")
   val = iface_type
   if (not (val in admitted_iface_types)):
      msg = "Unsupported interface type: "+str(val)+"\nSupported values: "+str(admitted_iface_types)
      sys.stderr.write(msg+'\n')
      return TYPE_ERROR
   if(val == "DLS_TYPE_DLI"):
      iface_type = dlsClient.DLS_TYPE_DLI
   if(val == "DLS_TYPE_DBS"):
      iface_type = dlsClient.DLS_TYPE_DBS
   if(val == "DLS_TYPE_LFC"):
      iface_type = dlsClient.DLS_TYPE_LFC
   if(val == "DLS_TYPE_MYSQL"):
      iface_type = dlsClient.DLS_TYPE_MYSQL


 # Check option combinations...
   if(errorTolerant and (not fromFile)):
      sys.stderr.write("Bad usage: The -p option can only be used together with -f"+'\n')
      usage()
      return OPT_ERROR

   # From file
   if(fromFile):
      try:
         file=open(fname, 'r')
      except IOError, inst:
         msg="The file "+fname+" could not be opened: "+str(inst)+"\n"
         sys.stderr.write(msg)
         return FILE_ERROR
      lineList=file.readlines()
      
   # From command line options
   else:
      if(len(args)<1):
         sys.stderr.write("Not enough input arguments\n")
         usage()
         return(OPT_ERROR)

      line=""
      for token in args:
         line += token +" "
      lineList = [line]

 # Create the interface binding
   try:
      iface = dlsClient.getDlsApi(iface_type, endpoint, dbs_client_config = dbsConf)
      if(verbose == 2):
         iface.setVerbosity(dlsApi.DLS_VERB_HIGH)
      else:
         if(verbose == 0):
            iface.setVerbosity(dlsApi.DLS_VERB_NONE)
         else:
            if(verbose == 1):
               iface.setVerbosity(dlsApi.DLS_VERB_WARN)
   except dlsApi.DlsApiError, inst:
      if(inst.rc):  err = inst.rc 
      else:           err = GENERIC_ERROR
      msg = "Error when binding the DLS interface: " + str(inst)
      sys.stderr.write(msg+"\n")
      return err

   
 # Do the query (under session)
   try:
     showLocations(iface, lineList, longList, errorTolerant, verbose)
   except dlsApi.DlsApiError, inst:         
      if(inst.rc):  err = inst.rc 
      else:           err = GENERIC_ERROR
      msg = "Error in the DLS query: %s." % str(inst)
      sys.stderr.write(msg+'\n')


 # Finally, return error code
   return err



######################### SCRIPT ###########################

if __name__ == "__main__":
  sys.exit(main(sys.argv[1:]))

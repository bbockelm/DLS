#!/usr/bin/env python

#
# $Id: dls-add,v 1.13 2007/02/05 15:36:51 delgadop Exp $
#
# DLS Client. $Name:  $.
# Antonio Delgado Peris. CIEMAT. CMS.
# 

#########################################
# Imports 
#########################################
import dlsApi
DLS_VERB_HIGH = dlsApi.DLS_VERB_HIGH
DLS_VERB_WARN = dlsApi.DLS_VERB_WARN
from dlsDataObjects import DlsLocation, DlsFileBlock, DlsEntry, DlsDataObjectError
import dlsClient
import os
import sys
import commands
import getopt


######################### FUNCTIONS ########################

def usage():
   """
    Provides usage information
   """
   print "Usage: dls-add [-v, -t, -e, -i, ...] <fileblock> [attr=val ..] [<SE> [attr=val ..] ..]"
   print "       dls-add [-v, -t, -e, -i, ...] -f <listing_file>"
   print "       dls-add -u"
   print "       dls-add -h"

def options():
   """
    Provides some information regarding the available options
   """
   print """Options summary:
   -h, --help
   -u, --usage
   -v, --verbose <verb_level>
   -t, --transaction
   -e, --endpoint <endpoint>
   -i, --interface-type <iface_type>
   -f, --from-file <filename>
       --skip-location-check
       --allow-empty-blocks
   """

def example():
  """
   Provides with an example of correct use of the script
  """
  print """
  """

def help():
   """
    Provides some help information
   """
   print """Creates a FileBlock in the DLS server and associates the specified
locations (SEs) with it. If the FileBlock already exists, then it just adds the
specified locations.

FileBlock attributes can be specified after the FileBlock name (and before any
location), and are identified by the '=' sign joining key and value for each
attribute (there must be no spaces between them). Likewise, location attributes
can be specified after each given location. Unknown attribute names (keys)
will be ignored.

Currently understood fileblock attributes are:    
      guid, filemode, filesize, csumtype, csumvalue

Currently understood replica attributes are:    
      sfn, f_type, ptime

For hierarchical DLS catalogs, the parent directories of the specified FileBlock
are checked for existence, and created if non existing.

The "--skip-location-check" option can be used to skip the check of locations
to be added. If not used, the location hostname is checked for IP resolution
in order to be accepted as valid location.

The "--allowEmptyBlocks" option indicates that FileBlocks with no associated
locations may be added to DLS (default is any FileBlock requires at least
one location to be defined).

The "-f" option can be used to retrieve FileBlock names from a file rather than
from the given arguments. The file must contain one line per FileBlock to be added,
optionally with some attributes, then the SEs to associate as locations and
perhaps the attributes for them; all in the same line and separated by whitespaces.
In this case, the other options have the same meaning as before and affect all
FileBlocks in <listfile>.

The "-t" option indicates if transactions should be used. In that case, any error
in an operation provokes a stop (no more additions) and a rollback of the previous
operations. Otherwise (no transactions), after a failure in one replica, the tool
tries to go on with next locations (and FileBlocks).

NOTE: It is not recommended to maintain a transaction for too long (~10 seconds).
Thus, it is suggested not to include too many FileBlock in a <listfile> if
transactions are to be used. For a larger number of FileBlocks, please split them
into several invocations of the command.

The "-e" option can be used to set the DLS endpoint to use. If not specified,
the endpoint is retrieved from:
    - DLS_ENDPOINT environmental variable
If the DLS endpoint cannot be retrieved in any of these ways the command fails.
The endpoint should be of the form: "hname[:port][/path/to/DLS]", where a
default port is used if not specified, and the path to DLS may be required for
some DLS implementations (and ignored otherwise).

The "-i" option specifies the type of interface that should be used (which
depends on the DLS backend to access). If not specified, the interface type
is retrieved from:
    - DLS_TYPE environmental variable
If the interface type cannot be retrieved in any of these ways, the command fails.
Currently accepted values are:
    - DLS_TYPE_LFC  =>  DlsLfcApi class (complete API with LFC back-end)
    - DLS_TYPE_DLI  =>  DlsDliClient class (getLocations only API with LFC back-end)
    - DLS_TYPE_MYSQL =>  DlsMySQLApi  class (complete API with MySQL proto back-end) 

The "-v" option sets the verbosity level for the command. Accepted values are:
  -v 0 ==> print nothing else than error messages
  -v 1 ==> print also warning messages (default)
  -v 2 ==> print extra debug information

If "-u" is specified, usage information is displayed.

If "-h" is specified, help information is displayed.
   """
   options()
   usage()



def insertEntries(iface, lineList, createParent, trans, verbose, checkHost, allowEmpty):
   """
    Tries to add the specified FileBlocks and locations for each of the lines
    in lineList. These lines are strings containing information regarding the
    FileBlock name (LFN), its attributes, and possibly several SEs where a
    location is located and the attributes for them. 

    The format of a line is then:
    <lfn> [attr_lfn_1=val ..] [<se1> [attr_se1_1=val ..] ..]

    All elements separated by whitespaces, and attributes identified by the presence
    of the '=' character.

    Throws DlsLfcApiError if there is a problem in the DLS operation, unless
    trans is set to True.
   """

   entryList = []

   for line in lineList:

      # Split
      line = (line.strip()).split()
      if(not line):
         continue
         
      # First is LFN
      lfn = line.pop(0)
      entry = DlsEntry(DlsFileBlock(lfn)) 


      # Then the LFN's attributes (key=val)
      attrDict = {}
      while(line):
         token=line[0]
         pos = token.find('=')
         if( pos == -1):
            break
         else:
            line.pop(0)
            attrDict[token[:pos]] = token[(pos+1):]            
      entry.fileBlock.attribs = attrDict

      # Then the SEs
      attrDict = {}      
      se = ''
      locList = []
      for token in line:
         pos = token.find('=')
         if( pos == -1):
            if(se):
               loc = DlsLocation(se)
               loc.attribs = attrDict               
               locList.append(loc)
            se = token
            attrDict = {}
         else:
            attrDict[token[:pos]] = token[(pos+1):]

      # And the last one, which is left... 
      if(se):
         locList.append(DlsLocation(se, attrDict))

      # Now check the locations (unless told otherwise)
      if(checkHost):
          for loc in locList:
             try:             
               loc.checkHost = True
               loc.host = loc.host
               entry.locations.append(loc)
             except DlsDataObjectError, inst:
               msg = "Wrong location %s for "%(loc.host)
               msg += "FileBlock %s: %s" % (entry.fileBlock.name, inst.msg)
               if(trans):
                  inst.msg = msg
                  raise inst
               else:
                  if(verbose >= 1):
                     print "Warning: Skipping location. " + msg
      else:
          entry.locations = locList

      # Check there was some location left
      if(not allowEmpty):
         if(not entry.locations):
            msg = "FileBlock %s with no associated location." % (lfn)
            if(trans):
               raise DlsDataObjectError("Error: "+msg)
            else:
               if(verbose >= 1):
                   print "Warning: Skipping " + msg
               continue

      # Store entry
      entryList.append(entry)

   if(verbose >= 2):
      print "--DlsApi.add(",
      for i in entryList: print i, ";",
      print ")"

   # Finally, do the insertion (and let the caller deal with the exception...)
   iface.add(entryList, createParent=createParent, trans=trans,session=not trans, checkLocations=False,allowEmptyBlocks=allowEmpty)

            

###################### MAIN FUNCTION ########################

def main(pArgs):
   """
    Performes the main task of the script (invoked directly).
    For information on its functionality, please call the help function.
   """

 # Options and args... 
   longoptions=["help", "usage", "transaction", "endpoint", "interface-type", "verbose","from-file", "skip-location-check", "allow-empty-blocks"]
   try:
      optlist, args = getopt.getopt(pArgs, 'hute:i:v:f:', longoptions)
   except getopt.GetoptError, inst:
      sys.stderr.write("Bad usage: "+str(inst)+'\n')
      usage()
      sys.exit(-1)

   err=0
   createParent = True
   trans = False
   checkHost = True
   allowEmpty = False
   admitted_verb_values = [0, 1, 2]
   verbose = 1
   endpoint = None
   iface_type = None
   admitted_iface_types = ["DLS_TYPE_LFC", "DLS_TYPE_DLI", "DLS_TYPE_MYSQL"]
   fromFile = False
   fname=""
   for opt, val in optlist:
       if opt in ("-h", "--help"):
           help()
           return -1

       elif opt in ("-u", "--usage"):
           usage()
           return -1
           
       elif opt in ("", "--skip-location-check"):
           checkHost = False

       elif opt in ("", "--allow-empty-blocks"):
           allowEmpty = True

       elif opt in ("-t", "--transaction"):
           trans = True

       elif opt in ("-e","--endpoint"):
           endpoint = val

       elif opt in ("-i", "--interface-type"):
           if (not (val in admitted_iface_types)):
              msg = "Unsupported interface type: " + val
              msg += "\nSuppported values: %s\n"%admitted_iface_types
              sys.stderr.write(msg)
              return -1
           if(val == "DLS_TYPE_LFC"):
              iface_type = dlsClient.DLS_TYPE_LFC
           if(val == "DLS_TYPE_DLI"):
              iface_type = dlsClient.DLS_TYPE_DLI
           if(val == "DLS_TYPE_MYSQL"):
              iface_type = dlsClient.DLS_TYPE_MYSQL

       elif opt in ("-v", "--verbose"):
           try: 
             val = int(val)
           except ValueError, inst:
             sys.stderr.write("Unsupported verbosity value: " + val + "\n")
             return -1
           if (not (val in admitted_verb_values)):
              sys.stderr.write("Unsupported verbosity value: " + val + "\n")
              return -1             
           verbose = val

       elif opt in ("-f","--from-file"):
           fromFile = True
           fname = val
           
  
 # Build the arguments 

   # From file
   if(fromFile):
      try:
         file=open(fname, 'r')
      except IOError, inst:
         msg="The file "+fname+" could not be opened: "+str(inst)+"\n"
         sys.stderr.write(msg)
         return -1
      lineList=file.readlines()
      
   # From command line options
   else:
      if(len(args)<1):
         sys.stderr.write("Not enough input arguments\n")
         usage()
         return(-1)

      line=""
      for token in args:
         line += token +" "
      lineList = [line]


 # Create the interface binding
   try:
      iface = dlsClient.getDlsApi(iface_type, endpoint)
      if(verbose == 2):
         iface.setVerbosity(dlsApi.DLS_VERB_HIGH)
      else:
         if(verbose == 0):
            iface.setVerbosity(dlsApi.DLS_VERB_NONE)
         else:
            if(verbose == 1):
               iface.setVerbosity(dlsApi.DLS_VERB_WARN)
   except dlsApi.DlsApiError, inst:
      if(inst.rc):  err = inst.rc 
      else:         err = -1
      msg = "Error when binding the DLS interface: " + str(inst)
      sys.stderr.write(msg+"\n")
      return err

   try:
     insertEntries(iface, lineList, createParent, trans, verbose, checkHost, allowEmpty)
   except DlsDataObjectError, inst:
     msg = "Error preparing the DLS request: %s." % str(inst)
     sys.stderr.write(msg+"\n")
     sys.exit(-2)
   except dlsApi.DlsApiError, inst:         
      if(inst.rc):  err = inst.rc 
      else:           err = -1
      msg = "Error in the entry(ies) insertion: %s." % str(inst)
      sys.stderr.write(msg+'\n')


 # Finally, return error code
   return err



######################### SCRIPT ###########################

if __name__ == "__main__":
  sys.exit(main(sys.argv[1:]))

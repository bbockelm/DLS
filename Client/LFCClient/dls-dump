#!/usr/bin/env python

#
# $Id: dls-dump,v 1.3 2007/02/05 15:39:56 delgadop Exp $
#
# DLS Client. $Name:  $.
# Antonio Delgado Peris. CIEMAT. CMS.
# 

#########################################
# Imports 
#########################################
import dlsApi
DLS_VERB_HIGH = dlsApi.DLS_VERB_HIGH
DLS_VERB_WARN = dlsApi.DLS_VERB_WARN
from dlsDataObjects import DlsLocation, DlsFileBlock, DlsEntry
import dlsClient
from dlsCommandsCommon import *
import time
from os import environ
import sys
import commands
import getopt


################## GLOBAL CONSTANTS ########################
THIS_YEAR = time.localtime()[0]


######################### FUNCTIONS ########################

def usage():
   """
    Provides usage information
   """
   print "Usage: dls-dump [-v, -e, -i, -r, --dbs-conf] <what>"
   print "       dls-dump -u"
   print "       dls-dump -h"


def options():
   """
    Provides some information regarding the available options
   """
   print """Options summary:
   -h, --help
   -u, --usage
   -v, --verbose <verb_level>
   -e, --endpoint <endpoint>
   -i, --interface-type <iface_type>
   -r, --recursive
       --dbs-conf <conf_file>
   """
def example():
  """
   Provides with an example of correct use of the script
  """
  print """
  """

def help():
   """
    Provides some help information
   """
   print """This script will print DLS entries. The printed information will
include both FileBlock names and associated locations. The interpretation
of the argument <what_to_print> depends on the back-end DLS server, as
explained below.


Specific notes for DBS back-end (DLS_TYPE_DBS):

  DBS' FileBlock namespace is flat, and so there are no directories. The
  argument of this command will be taken as a FileBlock pattern, and information
  regarding the matching FileBlocks will be returned. If only "/" is specified,
  this will be interpreted as "dump the whole catalog". The "-r" option is
  ignored.

  The server endpoint is got from a string in the URL form, usually:
    "http[s]://hname[:port]/path/to/DLS".
  This endpoint is retrieved from several sources (in order of precedence):   
     - specified value for --endpoint option 
     - DLS_ENDPOINT environmental variable
     - specified URL in the configuration file (see --dbs-conf)

  Apart from DBS endpoint, other configuration options may be specified for
  the underlying DBS interface (e.g. the compulsory DBS client version) in a
  configuration file. The name of this file can be indicated with,
  in this order:
     - specified value for --dbs-conf option
     - DBS_CLIENT_CONFIG environmental variable


Specific notes for LFC back-end (DLS_TYPE_LFC):

  LFC implements a hierarchical FileBlock namespace. The argument of this
  command will be taken as a directory in that namespace, and its containing
  FileBlocks and associated locations will be dumped.

  The "-r" option makes the dumping recursive. That is, the command will print
  also the contents of the subdirectories of under the specified directory.
  
   NOTE: Be aware that the recursive dumping of LFC is a very costly operation
   and may affect DLS response, so please use this flag only with care!!

  The server endpoint should be of the form: "hname[:port][/path/to/DLS]",
  where a default port is used if not specified, and the path to DLS is
  required. The server endpoint is retrieved from (in orden of precedence):
     - specified value for --endpoint option 
     - DLS_ENDPOINT environmental variable



Options:

The "-r" option makes the dumping recursive.

The "--dbs-conf" option can be used to specify a configuration file for the
DBS interface.

The "-e" option can be used to set the DLS endpoint to use.

The "-i" option specifies the type of interface that should be used (which
depends on the DLS backend to access). If not specified, the interface type
is retrieved from:
    - DLS_TYPE environmental variable
If the interface type cannot be retrieved in any of these ways, the command fails.
Currently accepted values are:
    - DLS_TYPE_DBS =>   DLS_TYPE_DBS class (complete API with DBS back-end)
    - DLS_TYPE_LFC  =>  DlsLfcApi class (complete API with LFC back-end)
    - DLS_TYPE_MYSQL =>  DlsMySQLApi  class (complete API with MySQL proto back-end) 

The "-v" option sets the verbosity level for the command. Accepted values are:
  -v 0 ==> print nothing else than error messages
  -v 1 ==> print also warning messages (default)
  -v 2 ==> print extra debug information

If "-u" is specified, usage information is displayed.

If "-h" is specified, help information is displayed.
   """
   options()
   usage()



def showEntries(iface, dir, recursive, verbose):
   """
    Prints the entries under the specified FileBlock directory.
    Argument dir is a string, holding the directory name. 
    Argument recursive indicates if information of subdirectories
    should be also printed, in a recursive way.
    
    Throws DlsLfcApiError if there is a problem in the DLS operation.
   """

   # Get the Entries (and let the caller deal with the exception...)
   if(verbose >= 2):
      print "--DlsApi.dumpEntries(%s, recursive = %s)" % (dir, recursive)
   entryList = iface.dumpEntries(dir, recursive = recursive, session = True)
   

   # Print the list
   for i in entryList:
      print i.simpleStr()

            

###################### MAIN FUNCTION ########################

def main(pArgs):
   """
    Performes the main task of the script (invoked directly).
    For information on its functionality, please call the help function.
   """

 # Options and args... 
 
   longoptions=["help", "usage", "endpoint", "interface-type","verbose","recursive", "dbs-conf="]
   try:
      optlist, args = getopt.getopt(pArgs, 'hue:i:v:r', longoptions)
   except getopt.GetoptError, inst:
      sys.stderr.write("Bad usage: "+str(inst)+'\n')
      usage()
      sys.exit(OPT_ERROR)

   err=0
   dbsConf = None
   admitted_verb_values = [0, 1, 2]
   verbose = 1
   endpoint = None
   iface_type = None
   admitted_iface_types = ["DLS_TYPE_LFC", "DLS_TYPE_DBS", "DLS_TYPE_MYSQL"]
   recursive = False
   for opt, val in optlist:
       if opt in ("-h", "--help"):
           help()
           return OPT_ERROR

       elif opt in ("-u", "--usage"):
           usage()
           return OPT_ERROR
           
       elif opt in ("", "--dbs-conf"):
           dbsConf = val

       elif opt in ("-e","--endpoint"):
           endpoint = val

       elif opt in ("-i", "--interface-type"):
           iface_type = val

       elif opt in ("-v", "--verbose"):
           try: 
             val = int(val)
           except ValueError, inst:
             sys.stderr.write("Unsupported verbosity value: " + val + "\n")
             return OPT_ERROR
           if (not (val in admitted_verb_values)):
              sys.stderr.write("Unsupported verbosity value: " + val + "\n")
              return OPT_ERROR             
           verbose = val

       elif opt in ("-r","--recursive"):
           recursive = True


   # Check the interface type (from options or environ)
   if (not iface_type):
      iface_type = environ.get("DLS_TYPE")
   val = iface_type
   if (not (val in admitted_iface_types)):
      msg = "Unsupported interface type: "+str(val)+"\nSupported values: "+str(admitted_iface_types)
      sys.stderr.write(msg+'\n')
      return TYPE_ERROR
   if(val == "DLS_TYPE_DBS"):
      iface_type = dlsClient.DLS_TYPE_DBS
   if(val == "DLS_TYPE_LFC"):
      iface_type = dlsClient.DLS_TYPE_LFC
   if(val == "DLS_TYPE_MYSQL"):
      iface_type = dlsClient.DLS_TYPE_MYSQL


 # Get the arguments
   if(len(args)<1):
      sys.stderr.write("Not enough input arguments\n")
      usage()
      return(OPT_ERROR)

   dir = args[0]

 # Create the interface binding
   try:
      iface = dlsClient.getDlsApi(iface_type, endpoint, dbs_client_config = dbsConf)
      if(verbose == 2):
         iface.setVerbosity(dlsApi.DLS_VERB_HIGH)
      else:
         if(verbose == 0):
            iface.setVerbosity(dlsApi.DLS_VERB_NONE)
         else:
            if(verbose == 1):
               iface.setVerbosity(dlsApi.DLS_VERB_WARN)
   except dlsApi.DlsApiError, inst:
      if(inst.rc):  err = inst.rc 
      else:           err = GENERIC_ERROR
      msg = "Error when binding the DLS interface: " + str(inst)
      sys.stderr.write(msg+"\n")
      return err

   
 # Do the query (under session)
   try:
     showEntries(iface, dir, recursive, verbose)
   except dlsApi.DlsApiError, inst:         
      if(inst.rc):  err = inst.rc 
      else:           err = GENERIC_ERROR
      msg = "Error in the DLS query: %s." % str(inst)
      sys.stderr.write(msg+'\n')

 # Finally, return error code
   return err



######################### SCRIPT ###########################

if __name__ == "__main__":
  sys.exit(main(sys.argv[1:]))

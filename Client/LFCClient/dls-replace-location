#!/usr/bin/env python

#
# $Id: dls-replace-location,v 1.9 2007/03/27 09:58:37 delgadop Exp $
#
# DLS Client. $Name:  $
# Alessandra Fanfani Univ./INFN Bologna. CMS.
# 

#########################################
# Imports 
#########################################
import dlsApi
DLS_VERB_HIGH = dlsApi.DLS_VERB_HIGH
DLS_VERB_WARN = dlsApi.DLS_VERB_WARN
from dlsDataObjects import DlsLocation, DlsFileBlock, DlsEntry, DlsDataObjectError
import dlsClient
from dlsCommandsCommon import *
from os import environ
import sys
import commands
import getopt
from time import localtime, mktime


#########################################
# Constants 
#########################################
# Max duration of a transaction (in seconds)
DLS_MAX_TRANS_TIME = 10.5


# TODO: When custodial flag is there, before replacing location we need to think
#       what we do in that case.


######################### FUNCTIONS ########################

def usage():
   """
    Provides usage information
   """
   print "Usage: dls-replace-location [-v, -e, -i, ...] -o <old_loc> -n <new_loc>"
   print "       dls-replace-location -u"
   print "       dls-replace-location -h"

def options():
   """
    Provides some information regarding the available options
   """
   print """Options summary:
   -h, --help
   -u, --usage
   -v, --verbose <verb_level>
       --skip-location-check
   -e, --endpoint <endpoint>
   -i, --interface-type <iface_type>
   -o, --oldlocation <oldlocation>
   -n, --newlocation <newlocation>
       --dbs-conf <conf_file>
   """
def example():
  """
   Provides with an example of correct use of the script
  """
  print """
  """

def help():
   """
    Provides some help information
   """

   print """Replaces the location for all fileblocks for the given <oldlocation> to
the given <newlocation> in the DLS server.


Specific notes for DBS back-end (DLS_TYPE_DBS):

  This operation is atomic, either the replacement is made for all fileblocks or
  for none of them.

  The server endpoint is got from a string in the URL form, usually:
    "http[s]://hname[:port]/path/to/DLS".
  This endpoint is retrieved from several sources (in order of precedence):   
     - specified value for --endpoint option 
     - DLS_ENDPOINT environmental variable
     - specified URL in the configuration file (see --dbs-conf)

  Apart from DBS endpoint, other configuration options may be specified for
  the underlying DBS interface (e.g. "level" for DBS logging level) in a
  configuration file. The name of this file can be indicated with,
  in this order:
     - specified value for --dbs-conf option
     - DBS_CLIENT_CONFIG environmental variable


Specific notes for LFC back-end (DLS_TYPE_LFC):

  For LFC back-end, this operation is performed as an atomic operation (using
  transactions), so either the whole replacement is performed or nothing is done.

   NOTE: This operation is costly, and will take some time to complete.

  The server endpoint should be of the form: "hname[:port][/path/to/DLS]",
  where a default port is used if not specified, and the path to DLS is
  required. The server endpoint is retrieved from (in orden of precedence):
     - specified value for --endpoint option 
     - DLS_ENDPOINT environmental variable


Options:

The "--skip-location-check" option can be used to skip the check of the new 
location. If not used, the location hostname is checked for IP resolution
in order to be accepted as valid location.

The "-e" option can be used to set the DLS endpoint to use.

The "-i" option specifies the type of interface that should be used (which
depends on the DLS backend to access). If not specified, the interface type
is retrieved from:
    - DLS_TYPE environmental variable
If the interface type cannot be retrieved in any of these ways, the command fails.
Currently accepted values are:
    - DLS_TYPE_DBS =>   DLS_TYPE_DBS class (complete API with DBS back-end)
    - DLS_TYPE_LFC  =>  DlsLfcApi class (complete API with LFC back-end)
    - DLS_TYPE_MYSQL =>  DlsMySQLApi  class (complete API with MySQL proto back-end) 

The "-v" option sets the verbosity level for the command. Accepted values are:
  -v 0 ==> print nothing else than error messages
  -v 1 ==> print also warning messages (default)
  -v 2 ==> print extra debug information

If "-u" is specified, usage information is displayed.

If "-h" is specified, help information is displayed.
   """
   options()
   usage()


###################### MAIN FUNCTION ########################

def main(pArgs):
   """
    Performes the main task of the script (invoked directly).
    For information on its functionality, please call the help function.
   """

 # Options and args... 

   longoptions=["help", "usage", "verbose", "endpoint", "interface-type", "oldlocation",\
                "newlocation", "skip-location-check", "dbs-conf="]
   try:
      optlist, args = getopt.getopt(pArgs, 'huv:e:i:o:n:', longoptions)
   except getopt.GetoptError, inst:
      sys.stderr.write("Bad usage: "+str(inst)+'\n')
      usage()
      sys.exit(OPT_ERROR)

   err=0
   dbsConf = None
   admitted_verb_values = [0, 1, 2]
   verbose = 1
   checkHost = True
   endpoint = None
   iface_type = None
   admitted_iface_types = ["DLS_TYPE_LFC", "DLS_TYPE_DBS", "DLS_TYPE_MYSQL"]
   oldlocation = None
   newlocation = None

   for opt, val in optlist:
     if opt in ("-h", "--help"):
         help()
         return OPT_ERROR

     elif opt in ("-u", "--usage"):
         usage()
         return OPT_ERROR
         
     elif opt in ("-v", "--verbose"):
         try: 
           val = int(val)
         except ValueError, inst:
           sys.stderr.write("Unsupported verbosity value: " + val + "\n")
           return OPT_ERROR
         if (not (val in admitted_verb_values)):
            sys.stderr.write("Unsupported verbosity value: " + val + "\n")
            return OPT_ERROR             
         verbose = val
         
     elif opt in ("", "--skip-location-check"):
         checkHost = False

     elif opt in ("", "--dbs-conf"):
         dbsConf = val

     elif opt in ("-e","--endpoint"):
         endpoint = val

     elif opt in ("-i", "--interface-type"):
           iface_type = val

     elif opt in ("-o", "--oldlocation"):
         oldlocation=val
     elif opt in ("-n", "--newlocation"):
         newlocation=val


   # Check the interface type (from options or environ)
   if (not iface_type):
      iface_type = environ.get("DLS_TYPE")
   val = iface_type
   if (not (val in admitted_iface_types)):
      msg = "Unsupported interface type: "+str(val)+"\nSupported values: "+str(admitted_iface_types)
      sys.stderr.write(msg+'\n')
      return TYPE_ERROR
   if(val == "DLS_TYPE_DBS"):
      iface_type = dlsClient.DLS_TYPE_DBS
   if(val == "DLS_TYPE_LFC"):
      iface_type = dlsClient.DLS_TYPE_LFC
   if(val == "DLS_TYPE_MYSQL"):
      iface_type = dlsClient.DLS_TYPE_MYSQL


   # Check other options
   if oldlocation==None:
      msg = "Error: --oldlocation <oldlocation> is required"
      sys.stderr.write(msg+"\n")
      usage()
      sys.exit(OPT_ERROR)
   if newlocation==None:
      msg = "Error: --newlocation <newlocation> is required"
      sys.stderr.write(msg+"\n")
      usage()
      sys.exit(OPT_ERROR)
   if oldlocation == newlocation:
      msg = "Error: <newlocation> (%s) and <oldlocation> (%s) are equal"%(oldlocation, newlocation)
      sys.stderr.write(msg+"\n")
      sys.exit(OPT_ERROR)


 # Build the object for new location
   try:
      newDlsLocation = DlsLocation(newlocation, checkHost = checkHost)
   except DlsDataObjectError, inst:
     msg = "Error preparing the DLS request: %s." % str(inst)
     sys.stderr.write(msg+"\n")
     sys.exit(-2)  

 # Create the interface binding
   try:
      iface = dlsClient.getDlsApi(iface_type, endpoint, dbs_client_config = dbsConf)
      if(verbose == 2):
         iface.setVerbosity(dlsApi.DLS_VERB_HIGH)
      else:
         if(verbose == 0):
            iface.setVerbosity(dlsApi.DLS_VERB_NONE)
         else:
            if(verbose == 1):
               iface.setVerbosity(dlsApi.DLS_VERB_WARN)
   except dlsApi.DlsApiError, inst:
      if(inst.rc):  err = inst.rc 
      else:         err = GENERIC_ERROR
      msg = "Error when binding the DLS interface: " + str(inst)
      sys.stderr.write(msg+"\n")
      return err
  

   # DBS: Atomic operation in API
   if(iface_type == dlsClient.DLS_TYPE_DBS):
      if(verbose>=2):
         print "--DlsApi.changeFileBlocksLocation(%s, %s, checkLocations=%s)" % (oldlocation, newlocation, checkHost)
      try:
         iface.changeFileBlocksLocation(oldlocation, newlocation, checkLocations=checkHost)
         return 0
      except dlsApi.DlsApiError, inst:
         msg = "Error replacing location for fileblocks: %s." % str(inst)
         sys.stderr.write(msg+"\n")
         if(inst.rc):  err = inst.rc 
         else:         err = GENERIC_ERROR
         return err  
  

   # Other interface types (LFC): non-atomic operation but with transactions
   if(verbose >= 2):
      print "*** Get FileBlocks given the location=%s"%oldlocation
   entryList=[]
   try:
      entryList=iface.getFileBlocks(oldlocation, session=True)
   except dlsApi.DlsApiError, inst:
      msg = "Error in the DLS query: %s." % str(inst)
      sys.stderr.write(msg+"\n")
      if(inst.rc):  err = inst.rc 
      else:         err = GENERIC_ERROR
      return err  

   if(verbose >= 2):
      print "*** Add all DLS entries with location=%s"%newlocation
      print "*** Delete all DLS entries with location=%s"%oldlocation
     
   newList = []
   t0 = mktime(localtime())
   iface.startTrans()
   try:
     # NOTE for LFC: Here we delete inside a transaction. This is dangerous and should
     # be normally avoided! This particular case is known to behave correctly.
     for oldEntry in entryList:
        newEntry = DlsEntry(oldEntry.fileBlock,[newDlsLocation])
        iface.add(newEntry, errorTolerant = False, checkLocations = False)
        iface.delete(oldEntry, errorTolerant = False, keepFileBlock = True)
        # Check time (each transaction should not be longer than DLS_MAX_TRANS_TIME)
        t1 = mktime(localtime())
        if((t1-t0)>DLS_MAX_TRANS_TIME):
           iface.endTrans()
           t0 = mktime(localtime())           
           iface.startTrans()

   except dlsApi.DlsApiError, inst:
     msg = "Error in deleting DLS entry: %s." % str(inst)
     msg += "\nPlease check for FileBlocks still in old location (maybe in new as well)."
     msg += " If the error was temporary, running the command again may fix it."
     if(inst.rc):  err = inst.rc 
     else:         err = GENERIC_ERROR
     sys.stderr.write(msg+"\n")
     iface.abortTrans()
     sys.exit(err)  

   iface.endTrans()

######################### SCRIPT ###########################

if __name__ == "__main__":
  sys.exit(main(sys.argv[1:]))
